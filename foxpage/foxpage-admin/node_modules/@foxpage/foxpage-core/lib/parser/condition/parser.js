Object.defineProperty(exports, "__esModule", { value: true });
exports.ConditionParserImpl = void 0;
const lodash_1 = require("lodash");
const foxpage_shared_1 = require("@foxpage/foxpage-shared");
const sandbox_1 = require("../sandbox");
const config_1 = require("./config");
const types_1 = require("./types");
const utils_1 = require("./utils");
class ConditionParserImpl {
    /**
     * parse
     *
     * @param {Context} ctx
     */
    parse(ctx) {
        const conditions = ctx.getOrigin(foxpage_shared_1.ContentType.CONDITION);
        conditions === null || conditions === void 0 ? void 0 : conditions.forEach(item => {
            const result = this.parseOne(item, ctx);
            ctx.updateResource(foxpage_shared_1.ContentType.CONDITION, item.id, {
                content: item,
                parsed: result.parsed,
                parseMessages: result.parseMessages,
                parseStatus: result.parseStatus,
            });
        });
    }
    parseOne(condition, ctx) {
        var _a;
        const parsed = {
            parseStatus: true,
            parseMessages: [],
        };
        if (!condition) {
            parsed.parsed = false;
            parsed.parseMessages = ['condition is null'];
            return parsed;
        }
        const conditionItem = condition.schemas[0];
        if (!conditionItem.type || !config_1.supportConditionTypes.includes(conditionItem.type)) {
            parsed.parseStatus = false;
            parsed.parseMessages = [
                `condition type: "${conditionItem.type}" not support in "${JSON.stringify(types_1.ConditionType)}"`,
            ];
            return parsed;
        }
        const _expressions = conditionItem.children || [];
        const expressions = _expressions.filter(Boolean);
        // if no expression always false.
        if (expressions.length === 0) {
            parsed.parsed = false;
            return parsed;
        }
        try {
            switch (conditionItem.type) {
                case types_1.ConditionType.AND:
                    parsed.parsed = expressions.every(expression => this.parseExpression(expression, ctx, parsed.parseMessages));
                    break;
                case types_1.ConditionType.OR:
                    parsed.parsed = expressions.some(expression => this.parseExpression(expression, ctx, parsed.parseMessages));
                    break;
                default:
                    parsed.parseMessages = [`condition type: "${conditionItem.type}" not support in [${config_1.supportConditionTypes}]`];
                    parsed.parsed = false;
                    break;
            }
        }
        catch (err) {
            (_a = parsed.parseMessages) === null || _a === void 0 ? void 0 : _a.push(err.message);
            parsed.parsed = false;
            return parsed;
        }
        return parsed;
    }
    parseExpression(expression, ctx, parseMessages = []) {
        const messages = [];
        if (!expression) {
            return false;
        }
        const { key, operation, value } = expression.props;
        const left = sandbox_1.executeString(key, ctx.variables, messages);
        if (messages.length > 0) {
            throw new Error(`parse key '${key}' fail.`);
        }
        const right = lodash_1.isString(value)
            ? utils_1.transformRightTypeByLeft(left, sandbox_1.executeString(value, ctx.variables, messages))
            : value;
        if (messages.length) {
            throw new Error(`parse value '${value}' fail`);
        }
        let result = false;
        let reg;
        switch (operation.toLowerCase()) {
            case 'lt':
                result = left < right;
                break;
            case 'lt_eq':
                result = left <= right;
                break;
            case 'gt':
                result = left > right;
                break;
            case 'gt_eq':
                result = left >= right;
                break;
            case 'eq':
                result = left == right;
                break;
            case 'un_eq':
                result = left != right;
                break;
            case 'ct':
                result = utils_1.isIncludesAble(left) && left.includes(right);
                break;
            case 'un_ct':
                result = utils_1.isIncludesAble(left) && !left.includes(right);
                break;
            case 'in_array':
                result = Array.isArray(right) && right.includes(left);
                break;
            case 'un_in_array':
                result = Array.isArray(right) && !right.includes(left);
                break;
            case 'regex':
                reg = lodash_1.isString(right) ? new RegExp(right) : right instanceof RegExp ? right : null;
                result = (typeof left === 'string' && (reg === null || reg === void 0 ? void 0 : reg.test(left))) || false;
                break;
            case 'un_regex':
                reg = lodash_1.isString(right) ? new RegExp(right) : right instanceof RegExp ? right : null;
                result = typeof left === 'string' && !(reg === null || reg === void 0 ? void 0 : reg.test(left));
                break;
            case 'regex_uncase':
                reg = lodash_1.isString(right) ? new RegExp(right, 'i') : right instanceof RegExp ? right : null;
                result = (typeof left === 'string' && (reg === null || reg === void 0 ? void 0 : reg.test(left))) || false;
                break;
            case 'un_regex_uncase':
                reg = lodash_1.isString(right) ? new RegExp(right, 'i') : right instanceof RegExp ? right : null;
                result = typeof left === 'string' && !(reg === null || reg === void 0 ? void 0 : reg.test(left));
                break;
            case 'sw':
                result = lodash_1.isString(left) && lodash_1.isString(right) && left.startsWith(right);
                break;
            case 'un_sw':
                result = lodash_1.isString(left) && lodash_1.isString(right) && !left.startsWith(right);
                break;
            case 'ew':
                result = lodash_1.isString(left) && lodash_1.isString(right) && left.endsWith(right);
                break;
            case 'un_ew':
                result = lodash_1.isString(left) && lodash_1.isString(right) && !left.endsWith(right);
                break;
            default:
                const msg = `expression "${JSON.stringify(expression)}" operation ${operation} not support in [${config_1.supportOperations}]`;
                throw new Error(msg);
        }
        const msg = `expression "${key}" ${operation} "${value}" value: ${result}.("${key}" -> "${left ? JSON.stringify(left) : ''}")`;
        messages.push(msg);
        messages.forEach(item => {
            parseMessages.push(item);
        });
        return result;
    }
}
exports.ConditionParserImpl = ConditionParserImpl;

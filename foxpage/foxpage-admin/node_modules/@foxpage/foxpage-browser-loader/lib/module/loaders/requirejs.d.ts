interface RequireJSFn {
    <T1 = any>(mods: [string], cb: (...libs: [T1]) => void, errorCb?: (error: Error) => void): void;
    <T1 = any, T2 = any>(mods: [string, string], cb: (...libs: [T1, T2]) => void, errorCb?: (error: Error) => void): void;
    <T1 = any, T2 = any, T3 = any>(mods: [string, string], cb: (...libs: [T1, T2, T3]) => void, errorCb?: (error: Error) => void): void;
}
declare type RequireJSContext = RequireJSFn;
interface RequireJS extends RequireJSFn {
    config(opt: Partial<{
        context: string;
        baseUrl: string;
        paths: Record<string, string>;
        waitSeconds: number;
        map: Record<string, Record<string, string>>;
    }>): RequireJSContext;
    s: {
        contexts: Record<string, any>;
    };
}
declare global {
    interface Window {
        require?: RequireJS;
        requirejs?: RequireJS;
        define?: {
            (moduleName: string, cb: () => any): void;
            amd?: Record<string, boolean>;
        };
        __FOXPAGE_REQUIREJS_CONTEXTS__: any[];
    }
}
export declare function safeConfigRequirePath(req: RequireJS, name: string, url?: string, requireContextName?: string): void;
/**
 * load amd module by requirejs
 * if result is undefined, try load again by alias name
 * @param name
 * @param param1
 */
export declare function loadAmdModule<T = any>(name: string, { alias, url, version }: {
    alias: string[];
    url: string;
    version?: string;
}): Promise<T>;
export declare function loadRequirejs(link: string): Promise<any>;
export declare function destroyLoadRequire(): void;
export {};

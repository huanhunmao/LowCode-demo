var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArray = exports.timeout = exports.omit = exports.pick = exports.getESModuleExport = exports.diff = exports.createLocaleHasFormatter = exports.formatLocale = exports.isNotNill = exports.format = exports.mapObjectAsync = exports.mapObject = exports.eachObject = exports.filterObject = exports.buildMapFromIterator = exports.indexArray = void 0;
const lodash_1 = __importStar(require("lodash"));
function indexArray(array, prop) {
    return array.reduce((map, item) => {
        const key = item[prop];
        if (key && map[key] === undefined) {
            map[key] = item;
        }
        return map;
    }, {});
}
exports.indexArray = indexArray;
function buildMapFromIterator(iterator, keyProp) {
    const map = new Map();
    for (const item of iterator) {
        const key = item[keyProp];
        const strKey = (typeof key === 'string' || typeof key === 'number') && String(key);
        if (strKey && !map.has(strKey)) {
            map.set(String(key), item);
        }
    }
    return map;
}
exports.buildMapFromIterator = buildMapFromIterator;
function filterObject(source, cb) {
    return Object.entries(source)
        .filter(([_, v]) => cb(v))
        .reduce((target, [k, v]) => {
        target[k] = v;
        return target;
    }, {});
}
exports.filterObject = filterObject;
function eachObject(source, cb) {
    return Object.entries(source).forEach(([k, v]) => {
        cb(v, k);
    });
}
exports.eachObject = eachObject;
function mapObject(source, cb, filterNull = false) {
    return Object.entries(source).reduce((target, [k, v]) => {
        const res = cb(v, k);
        if (!(filterNull && res === undefined)) {
            target[k] = res;
        }
        return target;
    }, {});
}
exports.mapObject = mapObject;
async function mapObjectAsync(source, cb) {
    const target = {};
    const entries = Object.entries(source);
    const promises = entries.map(([k, v]) => cb(v, k)
        .then(res => (target[k] = res))
        .catch(() => (target[k] = undefined)));
    await Promise.all(promises);
    return target;
}
exports.mapObjectAsync = mapObjectAsync;
function format(str, ...params) {
    const len = params.length;
    let idx = 0;
    let formatted = str.replace(/%[d|s|j|%]/g, matched => {
        if (matched === '%%') {
            return '%';
        }
        if (idx < len) {
            const param = params[idx];
            idx += 1;
            switch (matched) {
                case '%d':
                    return String(Number(param));
                case '%s':
                    return String(param);
                case '%j':
                    return JSON.stringify(param);
            }
        }
        return matched;
    });
    for (; idx < params.length; idx++) {
        const element = params[idx];
        formatted += '\n';
        if (element instanceof Error) {
            formatted += element.stack;
        }
        else if (typeof element === 'object') {
            try {
                formatted += JSON.stringify(element);
            }
            catch (_err) {
                formatted += String(element);
            }
        }
        else {
            formatted += String(element);
        }
    }
    return formatted;
}
exports.format = format;
function isNotNill(val) {
    return val !== undefined && val !== null && val !== false;
}
exports.isNotNill = isNotNill;
/**
 *
 * @param locale locale
 * @param style aa_bb, aa-bb, aa_BB,  aa-BB, AA_BB, AA-BB,  AA_bb,  AA-bb
 */
exports.formatLocale = (locale = 'en-US') => {
    const [lang = '', zone = ''] = locale.split(locale.includes('-') ? '-' : '_');
    return (style) => style
        .replace('aa', lang.toLowerCase())
        .replace('AA', lang.toUpperCase())
        .replace('bb', zone.toLowerCase())
        .replace('BB', zone.toUpperCase());
};
exports.createLocaleHasFormatter = (locale = 'en-US') => {
    const str = new String(locale);
    const formatter = exports.formatLocale(locale);
    str.localeFormat = formatter;
    return str;
};
exports.diff = (oldData, newData, key, areEqual = lodash_1.isEqual) => {
    const oldDataMap = indexArray(oldData, key);
    const adds = [];
    const updates = [];
    const deletes = [];
    for (const newItem of newData) {
        const id = newItem[key];
        const oldItem = oldDataMap[id];
        if (id in oldDataMap) {
            delete oldDataMap[id];
            if (areEqual(oldItem, newItem)) {
                continue;
            }
            else {
                updates.push(newItem);
            }
        }
        else {
            adds.push(newItem);
        }
    }
    deletes.push(...Object.values(oldDataMap));
    return {
        adds,
        updates,
        deletes,
    };
};
function getESModuleExport(mod) {
    // esModule
    if (typeof mod === 'object' && mod !== null && mod.__esModule && 'default' in mod) {
        return mod;
    }
    return { default: mod };
}
exports.getESModuleExport = getESModuleExport;
function pick(obj, keys) {
    if (!obj) {
        return {};
    }
    return keys.reduce((result, key) => {
        if (key in obj) {
            result[key] = obj[key];
        }
        return result;
    }, {});
}
exports.pick = pick;
function omit(obj, keys) {
    return lodash_1.default.omit(obj, keys);
}
exports.omit = omit;
function timeout(promise, time) {
    return Promise.race([
        promise,
        new Promise((_resolve, reject) => {
            setTimeout(() => {
                reject(new Error('timeout'));
            }, time);
        }),
    ]);
}
exports.timeout = timeout;
function isArray(val) {
    return Object.prototype.toString.call(val) === '[object Array]';
}
exports.isArray = isArray;

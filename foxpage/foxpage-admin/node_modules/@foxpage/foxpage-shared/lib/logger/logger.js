var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLogger = void 0;
const format_util_1 = __importDefault(require("format-util"));
const lodash_1 = require("lodash");
const impl_1 = require("./impl");
const level_1 = require("./level");
class LoggerProvider {
    constructor(type, opt) {
        this.loggers = [];
        this.timerMap = new Map();
        this.init = (customizeLoggers = []) => {
            this.loggers = impl_1.Loggers.concat(...customizeLoggers).map(LoggerClass => new LoggerClass());
            return this;
        };
        this.debug = (msg, ...params) => {
            this.log(level_1.LOGGER_LEVEL.DEBUG, msg, params);
        };
        this.info = (msg, ...params) => {
            this.log(level_1.LOGGER_LEVEL.INFO, msg, params);
        };
        this.warn = (msg, ...params) => {
            this.log(level_1.LOGGER_LEVEL.WARN, msg, params);
        };
        this.error = (msg, ...params) => {
            this.log(level_1.LOGGER_LEVEL.ERROR, msg, params);
        };
        this.timeStart = (label, msg, ...params) => {
            const time = +new Date();
            this.timerMap.set(label, time);
            if (msg) {
                this.info(msg, ...params);
            }
            return (msg, ...params) => {
                this.timeEnd(label, msg, params);
            };
        };
        this.timeEnd = (label, msg, ...params) => {
            let cost = -1;
            const start = this.timerMap.get(label);
            if (start) {
                const now = +new Date();
                cost = now - start;
                this.debug('%s cost %d ms', label, cost);
                this.timerMap.delete(label);
            }
            if (msg) {
                this.info(msg, ...params, cost);
            }
            return cost;
        };
        this.log = (level, msg, params) => {
            if (level >= this.level) {
                const { prefix, method } = level_1.LOGGER_CONFIG[level];
                const err = params.find(lodash_1.isError);
                const errIndex = params.indexOf(err);
                const isErrorLog = level === level_1.LOGGER_LEVEL.ERROR;
                if (errIndex > -1 && isErrorLog) {
                    params.splice(errIndex, 1);
                }
                const formateMsg = this.formatMessage(prefix, msg, params);
                const args = isErrorLog
                    ? [formateMsg, err, this.type]
                    : [formateMsg];
                this.loggers.forEach(logger => {
                    logger[method].apply(logger, args);
                });
            }
        };
        this.formatMessage = (level, msg, params) => {
            var _a;
            let formateMsg = msg;
            try {
                formateMsg = format_util_1.default(msg, ...params);
            }
            catch (error) {
                this.error('format message "%s" fail', msg, error);
            }
            const output = `[Foxpage] ${((_a = this.option) === null || _a === void 0 ? void 0 : _a.procInfo) ? '<' + this.option.procInfo + '>' : ''} [ ${level} ] <${this.type}> ${formateMsg}`;
            return output;
        };
        this.toJSON = () => {
            return {
                name: this.type,
                level: level_1.LOGGER_LEVEL[this.level],
            };
        };
        this.type = type;
        this._level = (opt === null || opt === void 0 ? void 0 : opt.level) ? opt.level : level_1.LOGGER_LEVEL.INFO;
        this.option = opt;
        this.init(opt === null || opt === void 0 ? void 0 : opt.customizeLoggers);
    }
    // avoid circle error,
    get level() {
        return this._level;
    }
}
function createLogger(type, opt) {
    return new LoggerProvider(type, opt);
}
exports.createLogger = createLogger;

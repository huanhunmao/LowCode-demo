var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginLoaderImpl = void 0;
const path_1 = require("path");
const fs_extra_1 = __importDefault(require("fs-extra"));
const resolve_1 = __importDefault(require("resolve"));
const mode_1 = require("./mode");
/**
 * plugin loader impl
 *
 * @export
 * @class PluginLoaderImpl
 * @implements {PluginLoader}
 */
class PluginLoaderImpl {
    constructor(opt) {
        this.visitors = {};
        this.mode = mode_1.Mode.PIPE;
        this.pluginMap = new Map();
        this.baseDir = opt.baseDir;
        this.pluginDir = path_1.join(this.baseDir, 'node_modules/');
        this.list = Array.from(new Set(opt.plugins)) || [];
        this.api = opt.api;
        if (opt.mode) {
            this.mode = opt.mode;
        }
    }
    /**
     * get plugin entry
     *
     * @private
     * @param {string} name
     * @return {string}
     */
    resolvePlugin(name) {
        try {
            return resolve_1.default.sync(name, { basedir: this.baseDir });
        }
        catch (err) {
            return path_1.join(this.baseDir, 'node_modules', name);
        }
    }
    /**
     * load plugins
     *
     */
    load() {
        if (!fs_extra_1.default.existsSync(this.pluginDir)) {
            return null;
        }
        const emptyList = [];
        const modules = [];
        this.list.forEach((name) => {
            const path = this.resolvePlugin(name);
            if (fs_extra_1.default.existsSync(path)) {
                modules.push(name);
            }
            else {
                emptyList.push(name);
            }
        });
        if (emptyList.length > 0) {
            throw new Error(`plugins [ ${emptyList.toString()} ] not found.`);
        }
        for (const module of modules) {
            this.registerPlugin(module);
        }
        return this.mergeVisitors();
    }
    /**
     * register a plugin
     *
     * @param {string} name
     * @return {*}
     */
    registerPlugin(name) {
        try {
            const plugin = this.getPlugin(name);
            if (!plugin || !plugin.visitor) {
                throw new Error(`plugin [ ${name} ] is invalid`);
            }
            this.pluginMap.set(name, Object.assign(Object.assign({}, plugin), { name }));
        }
        catch (e) {
            throw new Error(`plugin [ ${name} ] load failed:` + e.message);
        }
    }
    /**
     * unregister a plugin
     *
     * @param {string} name
     * @memberof PluginLoaderImpl
     */
    unregisterPlugin(name) {
        this.pluginMap.delete(name);
        this.list = this.list.filter(item => item !== name);
    }
    /**
     * get a plugin
     *
     * @param {string} name
     * @return {*}
     */
    getPlugin(name) {
        if (this.hasPlugin(name)) {
            return this.pluginMap.get(name);
        }
        // all plugin must export default
        const plugin = require(this.pluginDir + name).default({ api: this.api });
        return plugin;
    }
    /**
     * get all plugin name list
     *
     * @return {string[]}
     */
    getList() {
        return Array.from(this.pluginMap.keys());
    }
    /**
     * check if exist the plugin
     *
     * @param {string} name
     * @return {boolean}
     */
    hasPlugin(name) {
        return !!this.pluginMap.has(name);
    }
    /**
     * merge visitors
     */
    mergeVisitors() {
        this.list.forEach(item => {
            var _a;
            const itemVisitor = (_a = this.pluginMap.get(item)) === null || _a === void 0 ? void 0 : _a.visitor;
            if (itemVisitor) {
                Object.keys(itemVisitor).forEach(key => {
                    if (!this.visitors[key]) {
                        this.visitors[key] = [];
                    }
                    if (this.visitors[key]) {
                        this.visitors[key].push(itemVisitor[key]);
                    }
                });
            }
        });
    }
    /**
     * get hooks
     * current only support Mode.PIPE
     * @return {*}
     */
    getHooks() {
        const hookKeys = Object.keys(this.visitors);
        if (hookKeys.length === 0) {
            return {};
        }
        const visitors = {};
        if (this.mode === mode_1.Mode.PIPE) {
            hookKeys.forEach(key => {
                const hooks = this.visitors[key];
                const executor = async (...args) => {
                    let result;
                    for (const hook of hooks) {
                        // core
                        result = await hook(...args);
                    }
                    return result;
                };
                visitors[key] = executor;
            });
        }
        else if (this.mode === mode_1.Mode.DISTRIBUTION) {
            hookKeys.forEach(key => {
                const hooks = this.visitors[key];
                const executor = async (...args) => {
                    const result = [];
                    for (const hook of hooks) {
                        // core
                        result.push(await hook(...args));
                    }
                    return result;
                };
                visitors[key] = executor;
            });
        }
        else if (this.mode === mode_1.Mode.COVER) {
            hookKeys.forEach(key => {
                const hooks = this.visitors[key];
                // core: get the last one
                visitors[key] = hooks[hooks.length - 1];
            });
        }
        return visitors;
    }
    /**
     * destroy
     */
    destroy() {
        this.pluginMap.clear();
    }
}
exports.PluginLoaderImpl = PluginLoaderImpl;

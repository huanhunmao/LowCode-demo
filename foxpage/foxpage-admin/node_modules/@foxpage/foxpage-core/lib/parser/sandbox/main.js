Object.defineProperty(exports, "__esModule", { value: true });
exports.evalWithScope = void 0;
/**
 * eval with scope
 *
 * @export
 * @template T
 * @param {Record<string, any>} scope
 * @param {string} expression
 * @return {*}  {T}
 */
function evalWithScope(scope, expression) {
    const __scope__ = new Proxy(scope, {
        get(target, key, receiver) {
            if (typeof key !== 'symbol') {
                if (key in target) {
                    return target[key];
                }
                if (key in global) {
                    return global[key];
                }
                throw new ReferenceError(`"${key}" is undefined.`);
            }
            return Reflect.get(target, key, receiver);
        },
        // expression 只能访问 scope 里面的变量
        has(_target, p) {
            if (p === '__tmp__') {
                return false;
            }
            return true;
        },
    });
    __scope__;
    // eslint-disable-next-line prefer-const
    let __tmp__ = undefined;
    try {
        eval(`
    with(__scope__) {
      __tmp__ = ${expression}
    }
  `);
    }
    catch (error) {
        error.message = `eval "${expression}" fail, reason: ${error.message}`;
        throw error;
    }
    return __tmp__;
}
exports.evalWithScope = evalWithScope;

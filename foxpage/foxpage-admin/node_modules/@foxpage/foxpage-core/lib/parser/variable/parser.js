Object.defineProperty(exports, "__esModule", { value: true });
exports.VariableParserImpl = void 0;
const foxpage_shared_1 = require("@foxpage/foxpage-shared");
const function_1 = require("../function");
const sandbox_1 = require("../sandbox");
const type_parsers_1 = require("./type-parsers");
const MAX_LOOP_COUNT = 20;
/**
 * variable parser
 *
 * @export
 * @class VariableParser
 */
class VariableParserImpl {
    constructor() {
        /**
         * parser maps
         *
         * @private
         */
        this.parserMap = new Map();
        this.functionParser = new function_1.FunctionParser();
        // register default variable parser
        this.register(type_parsers_1.sysVariableParseEntity);
        this.register(type_parsers_1.staticVariableParseEntity);
        this.maxLoopCount = 0;
    }
    /**
     * get variable parser by variable type
     *
     * @param {VariableType} type
     * @return {*}
     */
    get(type) {
        return this.parserMap.get(type);
    }
    /**
     * register the variable parser
     *
     * @param {VariableParseEntity} parser
     */
    register(parser) {
        if (!this.get(parser.type)) {
            this.parserMap.set(parser.type, parser);
        }
    }
    /**
     * register dynamic by hooks
     * @param hooks
     */
    async registerDynamic(hooks = {}) {
        // register parser by plugin dynamic
        const { registerVariableParser } = hooks;
        if (typeof registerVariableParser === 'function') {
            const parsers = (await registerVariableParser());
            if (parsers) {
                if (Array.isArray(parsers)) {
                    parsers.forEach(parser => {
                        this.register(parser);
                    });
                }
                else {
                    this.register(parsers);
                }
            }
        }
    }
    /**
     * unregister variable parser
     *
     * @param {VariableType} type
     */
    unRegister(type) {
        this.parserMap.delete(type);
    }
    /**
     * pre parse
     */
    preParse() {
        this.maxLoopCount = 0;
    }
    /**
     * parse variable
     *
     * @param {Context} ctx
     * @param {{ parsedVarSet: Set<string>; parsedFnSet: Set<string> }} { parsedVarSet: record parsed variableIds, parsedFnSet: record parsed functionIds }
     * @return {*}
     */
    async parse(ctx, { parsedVarSet = new Set(), parsedFnSet = new Set() }) {
        var _a;
        const variables = ctx.getOrigin(foxpage_shared_1.ContentType.VARIABLE);
        if ((variables === null || variables === void 0 ? void 0 : variables.length) === 0) {
            return;
        }
        try {
            let nextLoop = false;
            const echo = async (item) => {
                var _a;
                if (parsedVarSet.has(item.id)) {
                    return;
                }
                const existNoParsedFn = this.checkIn(parsedFnSet, item.functions);
                const existNoParsedVar = this.checkIn(parsedVarSet, item.variables);
                if (!existNoParsedFn && !existNoParsedVar) {
                    const variable = item.schemas[0];
                    const parser = this.createParser(ctx);
                    const { parsed, status, messages } = await parser(variable);
                    ctx.updateResource(foxpage_shared_1.ContentType.VARIABLE, variable.name, {
                        content: item,
                        parsed,
                        parseStatus: status,
                        parseMessages: messages,
                    });
                    parsedVarSet.add(item.id);
                }
                else {
                    if (existNoParsedFn) {
                        (_a = this.functionParser) === null || _a === void 0 ? void 0 : _a.parse(ctx, { parsedVarSet, parsedFnSet });
                    }
                    nextLoop = true;
                }
            };
            if (variables && variables.length > 0) {
                for (const item of variables) {
                    await echo(item);
                }
            }
            if (nextLoop) {
                if (this.maxLoopCount < MAX_LOOP_COUNT) {
                    this.maxLoopCount = this.maxLoopCount + 1;
                    await this.parse(ctx, { parsedVarSet, parsedFnSet });
                }
                else {
                    throw new Error('the variable loop parse failed: Maybe the variable is wrong or the variable dependency chain is too long');
                }
            }
        }
        catch (e) {
            (_a = ctx.logger) === null || _a === void 0 ? void 0 : _a.error('variable parse failed:', e);
        }
        return;
    }
    checkIn(collects, list) {
        return (list === null || list === void 0 ? void 0 : list.length) ? list.findIndex(item => !collects.has(item)) > -1 : false;
    }
    createParser(ctx) {
        return async (content) => {
            var _a, _b;
            const parser = this.get(content.type);
            const messages = [];
            if (parser) {
                // parse
                const resolvedProps = sandbox_1.executeObject(content.props, ctx.variables, messages);
                content.props = resolvedProps;
                try {
                    const parsed = await parser.parse(content, ctx);
                    return { parsed, status: true, messages };
                }
                catch (e) {
                    const msg = `parse variable@${content.name} failed: ${e.message}`;
                    (_a = ctx.logger) === null || _a === void 0 ? void 0 : _a.error(msg);
                    messages.push(msg);
                    return { parsed: null, status: false, messages: messages };
                }
            }
            else {
                const msg = `variable type ${content.type} not supported, should be "${[...this.parserMap.keys()]}"`;
                messages.push(msg);
                (_b = ctx.logger) === null || _b === void 0 ? void 0 : _b.error(msg);
                return { parsed: content, status: false, messages };
            }
        };
    }
}
exports.VariableParserImpl = VariableParserImpl;

Object.defineProperty(exports, "__esModule", { value: true });
exports.DirectiveParser = void 0;
const foxpage_shared_1 = require("@foxpage/foxpage-shared");
const sandbox_1 = require("../sandbox");
/**
 * directive parser
 *
 * @export
 * @class DirectiveParser
 */
class DirectiveParser {
    constructor(data) {
        this.parseItem = (target, expression, ctx, messages) => {
            var _a, _b;
            const _messages = new foxpage_shared_1.Messages();
            const result = sandbox_1.executeString(expression, ctx.variables, _messages);
            if (result === undefined) {
                (_a = ctx.logger) === null || _a === void 0 ? void 0 : _a.warn(`directive.${target} "${expression}" parse failed`, _messages);
            }
            else {
                (_b = ctx.logger) === null || _b === void 0 ? void 0 : _b.info(`directive.${target} "${expression}" parse succeed`);
            }
            _messages.forEach(item => {
                messages.push(item);
            });
            return result;
        };
        this.directives = data;
    }
    hasIf() {
        return this.directives.if && this.directives.if.length > 0;
    }
    hasTpl() {
        return !!this.directives.tpl;
    }
    parseIf(ctx, messages) {
        var _a, _b;
        try {
            const result = (_a = this.directives.if) === null || _a === void 0 ? void 0 : _a.map(item => this.parseItem('if', item || '', ctx, messages));
            return result === null || result === void 0 ? void 0 : result.every(Boolean);
        }
        catch (e) {
            (_b = ctx.logger) === null || _b === void 0 ? void 0 : _b.error(`directive.if parse failed`, messages);
            return false;
        }
    }
    parseTpl(ctx, messages) {
        return this.parseItem('tpl', this.directives.tpl || '', ctx, messages);
    }
}
exports.DirectiveParser = DirectiveParser;

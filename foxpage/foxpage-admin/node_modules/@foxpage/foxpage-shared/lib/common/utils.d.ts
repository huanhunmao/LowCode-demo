declare type GetRecordType<T, D = unknown> = T extends {
    [key: string]: infer R;
} ? R : D;
declare type PickKeyByValue<T, V = string | number> = {
    [P in keyof T]: T[P] extends V ? P : never;
}[keyof T];
export declare function indexArray<T, K extends PickKeyByValue<T>>(array: T[], prop: K): Record<string, T>;
export declare function buildMapFromIterator<T, K extends PickKeyByValue<T, string | number>>(iterator: Iterable<T>, keyProp: K): Map<string, T>;
export declare function filterObject<S>(source: S, cb: (val: GetRecordType<S>) => boolean): Partial<S>;
export declare function eachObject<S, U>(source: S, cb: (val: GetRecordType<S>, key: string) => U): void;
export declare function mapObject<S, U>(source: S, cb: (val: NonNullable<GetRecordType<S>>, key: string) => U, filterNull?: boolean): {
    [P in keyof S]: U;
};
export declare function mapObjectAsync<S, U>(source: S, cb: (val: GetRecordType<S>, key: string) => Promise<U>): Promise<{
    [P in keyof S]: U;
}>;
export declare function format(str: string, ...params: any[]): string;
export declare function isNotNill<T>(val: T | undefined | null | false): val is T;
export declare type LocaleStyle = 'aa_bb' | 'aa-bb' | 'aa_BB' | 'aa-BB' | 'AA_BB' | 'AA-BB' | 'AA_bb' | 'AA-bb';
export declare type LocaleWithFormatter = string & {
    localeFormat: ReturnType<typeof formatLocale>;
};
/**
 *
 * @param locale locale
 * @param style aa_bb, aa-bb, aa_BB,  aa-BB, AA_BB, AA-BB,  AA_bb,  AA-bb
 */
export declare const formatLocale: (locale?: string) => (style: LocaleStyle) => string;
export declare const createLocaleHasFormatter: (locale?: string) => LocaleWithFormatter;
export declare const diff: <T, K extends PickKeyByValue<T, string | number>>(oldData: T[], newData: T[], key: K, areEqual?: (oldItem: T, newItem: T) => boolean) => {
    adds: T[];
    updates: T[];
    deletes: T[];
};
export declare function getESModuleExport<T = any>(mod: unknown): {
    default: T;
};
export declare function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K>;
export declare function omit<T extends Record<string, any>, K extends keyof T>(obj: T, keys: K[]): Omit<T, K>;
export declare function timeout(promise: Promise<any>, time: number): Promise<unknown>;
export declare function isArray(val: any): val is any[];
export {};

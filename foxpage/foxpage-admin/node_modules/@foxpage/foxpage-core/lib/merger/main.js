Object.defineProperty(exports, "__esModule", { value: true });
exports.merge = exports.postMerge = exports.preMerge = void 0;
const foxpage_shared_1 = require("@foxpage/foxpage-shared");
const strategy_1 = require("./strategy");
const utils_1 = require("./utils");
/**
 * tree to record
 * for get extend parent node easy
 * @param tree tree data
 * @returns
 */
exports.preMerge = (trees) => {
    const record = {};
    function dfs(tree, parentId) {
        tree.forEach(item => {
            var _a, _b;
            record[item.id] = Object.assign(Object.assign({}, item), { extension: Object.assign(Object.assign({}, item.extension), { parentId }), children: [], childIds: (_a = item.children) === null || _a === void 0 ? void 0 : _a.map(item => item.id) });
            if ((_b = item.children) === null || _b === void 0 ? void 0 : _b.length) {
                dfs(item.children, item.id);
            }
        });
    }
    dfs(trees, '');
    return record;
};
/**
 * record to tree
 * @param records structure node records
 * @returns new tree
 */
exports.postMerge = (record) => {
    const roots = [];
    Object.keys(record).forEach(key => {
        const node = record[key];
        const { parentId } = node.extension || {};
        if (parentId) {
            // the invalid node
            // be care for use it
            if (!record[parentId]) {
                roots.push(node);
            }
        }
        else {
            roots.push(node);
        }
    });
    function dfs(list) {
        list.forEach(item => {
            const childIds = item.childIds || [];
            if (childIds.length > 0) {
                const children = childIds === null || childIds === void 0 ? void 0 : childIds.map(id => record[id]).filter(foxpage_shared_1.isNotNill).sort((one, two) => { var _a, _b; return (((_a = one.extension) === null || _a === void 0 ? void 0 : _a.sort) || 0) - (((_b = two.extension) === null || _b === void 0 ? void 0 : _b.sort) || 0); });
                item.children = children.length > 0 ? dfs(children) : [];
            }
            // avoid the extension data
            delete item.childIds;
        });
        return list;
    }
    const tree = dfs(roots);
    return tree;
};
/**
 * handle merge
 *
 * preMerge:transform the default schemas to record for get easy
 * doMerge: merge every node
 * postMerge:collect the merged node & transform to the tree(page structure)
 *
 * @param base base page content
 * @param current current page content
 * @param options merge options
 * @returns merge page content
 */
exports.merge = (base, current, options = { strategy: strategy_1.MergeStrategy.COMBINE }) => {
    const baseRecord = exports.preMerge(base.schemas);
    strategy_1.strategyMerge(baseRecord, current.schemas, options.strategy);
    const newSchemas = exports.postMerge(baseRecord);
    const result = Object.assign(Object.assign({}, current), { schemas: newSchemas, relation: utils_1.mergeObject(base.relation || {}, current.relation || {}) });
    return result;
};

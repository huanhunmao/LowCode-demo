var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TemplateParserImpl = void 0;
const lodash_1 = __importDefault(require("lodash"));
const foxpage_shared_1 = require("@foxpage/foxpage-shared");
const sandbox_1 = require("../sandbox");
/**
 * template parser impl
 *
 * @export
 * @class TemplateParserImpl
 * @implements {TemplateParser}
 */
class TemplateParserImpl {
    constructor() {
        this.templates = [];
        /**
         * tpl container mapï¼Œ for generate scope
         *
         * @type {Map<string, StructureNode>}
         */
        this.containerMap = new Map();
    }
    /**
     * prepare, set page root data
     *
     * @param {Context} ctx
     * @param {{ containerGetter?: (id: string) => StructureNode }} [opt]
     */
    preParse(ctx, opt) {
        this.templates = lodash_1.default.cloneDeep(ctx.origin.templates) || [];
        this.templates.forEach(template => {
            const tplContainer = (opt === null || opt === void 0 ? void 0 : opt.containerGetter) ? opt.containerGetter(template.id) : null;
            if (tplContainer) {
                this.containerMap.set(template.id, tplContainer);
            }
        });
    }
    /**
     * parse all template in render context
     *
     * @param {Context} ctx
     */
    parse(ctx) {
        this.templates.forEach(tpl => {
            var _a;
            const parser = this.tplParser(tpl, ctx);
            const { parsed, messages } = parser(tpl.schemas);
            (_a = ctx.logger) === null || _a === void 0 ? void 0 : _a.info(`template@${tpl.id} parsed`);
            ctx.updateResource(foxpage_shared_1.ContentType.TEMPLATE, tpl.id, {
                content: tpl,
                parsed: { id: tpl.id, schemas: parsed, relation: tpl.relation },
                parseStatus: true,
                parseMessages: messages,
            });
        });
    }
    tplParser(tpl, ctx) {
        const scope = this.containerMap.get(tpl.id);
        const messages = [];
        const parseFn = (list = []) => {
            let parseList = [];
            list.forEach(item => {
                const { props, directive, children } = item;
                // props parse
                if (props) {
                    const resolvedProps = sandbox_1.executeObject(props, Object.assign({ $this: scope }, ctx.variables), messages);
                    item.props = resolvedProps;
                }
                // directive parse
                if (directive && directive.tpl) {
                    const tpl = sandbox_1.executeString(directive.tpl, Object.assign({ $this: scope }, ctx.variables), messages);
                    // directive.tpl = undefined;
                    // item.children = tpl;
                    if (tpl) {
                        parseList = parseList.concat(tpl);
                    }
                    else {
                        const msg = `directive.tpl "${directive.tpl}" parse failed.`;
                        messages.push(msg);
                    }
                }
                else {
                    if (children && children.length > 0) {
                        const { parsed: childrenParsed } = parseFn(children);
                        parseList.push(Object.assign({}, item, { children: childrenParsed }));
                    }
                    else {
                        parseList.push(item);
                    }
                }
            });
            return { parsed: parseList, messages };
        };
        return parseFn;
    }
}
exports.TemplateParserImpl = TemplateParserImpl;

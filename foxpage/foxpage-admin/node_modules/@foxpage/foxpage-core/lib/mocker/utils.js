Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeProps = exports.preMock = exports.getUsedMocks = void 0;
/**
 * get the used mock
 *
 * @param mocks mocks
 * @param ctx context
 * @returns page and extend mock
 */
exports.getUsedMocks = (mocks = [], ctx) => {
    var _a, _b, _c;
    const mockMap = {};
    mocks.forEach(item => {
        mockMap[item.id] = item;
    });
    const { mockId = '', extendId = '' } = ((_a = ctx.getOrigin('page')) === null || _a === void 0 ? void 0 : _a.extension) || {};
    const pageMock = mockMap[mockId];
    let extendMock = null;
    if (extendId) {
        const extendMockId = (_c = (_b = ctx.getOrigin('extendPage')) === null || _b === void 0 ? void 0 : _b.extension) === null || _c === void 0 ? void 0 : _c.mockId;
        if (extendMockId) {
            extendMock = mockMap[extendMockId];
        }
    }
    return { pageMock, extendMock };
};
exports.preMock = (mock) => {
    var _a;
    const idMockMap = {};
    const typeMockMap = {};
    (_a = mock === null || mock === void 0 ? void 0 : mock.schemas) === null || _a === void 0 ? void 0 : _a.forEach(item => {
        if (item.id) {
            idMockMap[item.id] = item;
        }
        else if (item.name) {
            typeMockMap[item.name] = item;
        }
    });
    return { idMockMap, typeMockMap };
};
/**
 * merge props with mock
 * @param props
 * @param mockProps
 * @returns
 */
exports.mergeProps = (props, mockProps = {}) => {
    return Object.assign(Object.assign({}, props), mockProps);
};
